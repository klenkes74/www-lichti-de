---
layout: page
status: publish
published: true
title: Aufsetzen des GitHub-Repositories
thumbnail: /assets/thumbnail/ni0ByXc-300x225.jpg
author:
  display_name: klenkes74
  login: klenkes74
  email: roland@lichti.de
  url: ''
author_login: klenkes74
author_email: roland@lichti.de
wordpress_id: 771
wordpress_url: https://www.lichti.de/?p=771
date: '2021-04-19 08:00:00 +0200'
date_gmt: '2021-04-19 06:00:00 +0200'
categories:
- Softwareschnipsel
- OpenShift
- Deutsch
tags:
- build
- Java
- maven
- Software
- quay.io
- GitHub
- GitHub Actions
- CI/CD
- Pipeline
comments: []
---
<p><!-- wp:paragraph --></p>
<p>In diesem Teil der Artikelserie befassen wir uns mit dem GitHub-Repository und natürlich dem Workflow für die GitHub Actions.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Außerdem verliere ich ein paar Worte über den Maven-Build und die Integration des Helmcharts in diesen Build.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:more --><br />
<!--more--><br />
<!-- /wp:more --></p>
<p><!-- wp:paragraph --></p>
<p>Als erstes braucht man natürlich einen Account auf GitHub. Ich gehe aber mal davon aus, dass diese Hürde bereits genommen ist und in der Softwareindustrie eigentlich jeder schon über einen GitHub-Account verfügt. Aber selbst wenn dies nicht der Fall sein sollte, ist es ganz leicht, dazu braucht ihr meine Hilfe nicht.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Auch das Anlegen eines neuen Repositories ist ganz einfach.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":772,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-17-at-07.20.04-1024x120.png" alt="" class="wp-image-772"/><br />
<figcaption>Anlegen eines neuen Repositories. Auf das "+" klicken und dann "New repository" anwählen.</figcaption>
</figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>Danach öffnet sich eine neue Seite und man kann den gewünschten Namen eingaben. Hier kann man auch seine Lizenz aussuchen oder es auch sein lassen.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":773,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-17-at-07.23.33.png" alt="" class="wp-image-773"/></figure>
<p><!-- /wp:image --></p>
<p><!-- wp:heading --></p>
<h2>Der Software-Build mit Maven</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Danach hat man sein Repository und kann die Software dorthin installieren. Ich benutze mein Repository unter <a rel="noreferrer noopener" href="https://github.com/Paladins-Inn/delphi-council" target="_blank">https://github.com/Paladins-Inn/delphi-council</a> als Beispiel und gehe damit von einem Maven-Build (gesteuert durch die Datei <a rel="noreferrer noopener" href="https://github.com/Paladins-Inn/delphi-council/blob/development/pom.xml" target="_blank"><kbd>pom.xml</kbd></a> im Hauptverzeichnis) aus. Es handelt sich um eine Spring Boot Anwendung. Außerdem nutze ich Maven, um ein paar Parameter im Helm-Chart zu ersetzen. Die Sourcen des Helm-Charts leben unterhalb von <a rel="noreferrer noopener" href="https://github.com/Paladins-Inn/delphi-council/tree/development/src/main/helm/delphi-council-is" target="_blank"><kbd>./src/main/helm</kbd></a> und werden durch die Maven-Konfiguration nach <kbd>./target/helm</kbd> installiert:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"xml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    ...
    &lt;build>
        ...
        &lt;resources>
            ...
            &lt;resource>
                &lt;directory>src/main/helm&lt;/directory>
                &lt;targetPath>../helm&lt;/targetPath>
                &lt;filtering>true&lt;/filtering>
            &lt;/resource>
            ...
        &lt;/resources>
        ...
    &lt;/build>
    ...
&lt;/project></pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Da es sich um ein Spring-Boot-Projekt handelt, muss man aufpassen. Normalerweise ersetzt Maven Variablen im Format "<kbd>${VARIABLENNAME}</kbd>" - Spring-Boot Starter definieren es um und man muss die Notation "<kbd>@VARIABLENNAME@</kbd>" nutzen. Der targetPath oben ist wichtig, da für das Maven Resource-Plugin der Standard-Ausgabepfad <kbd>./target/classes</kbd> ist. Mit dem <kbd>&lt;targetPath&gt;../helm&lt;/targetPath&gt;</kbd> wird daraus <kbd>./target/helm</kbd>.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Ich nutze die Ersetzung vor allem, um die aktuelle Versionsnummer in die <kbd>Chart.yaml</kbd> zu bekommen. Das gleiche Spielchen mache ich übrigens auch mit dem <kbd>Dockerfile</kbd>, dass hier unter <kbd>./src/main/docker</kbd> liegt:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"xml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    ...
    &lt;build>
        ...
        &lt;resources>
            ...
            &lt;resource>
                &lt;directory>src/main/docker&lt;/directory>
                &lt;filtering>true&lt;/filtering>
            &lt;/resource>
            ...
        &lt;/resources>
        ...
    &lt;/build>
    ...
&lt;/project></pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Hier akzeptiere ich jedoch, dass das <kbd>Dockerfile</kbd> nach <kbd>./target/classes</kbd> kommt. Damit habe ich das <kbd>Dockerfile</kbd> auch im jar-Archiv und damit weiß jeder, wie die Software gebaut wurde. Das gefällt mir persönlich. Aber Ihr könnt gerne auch einen anderen <kbd>targetPath</kbd> konfigurieren. Bleibt aber unterhalb von <kbd>./target</kbd>, damit <kbd>mvn clean</kbd> alles automatisch wegräumt.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Der Rest des Maven Buildfiles befasst sich mit dem Softwarebuild, der neben dem Javabuild auch einen <kbd>npm</kbd>-basierten Build für das Frontend umfasst. Das kommt aber so mit dem von mir verwendeten Framework <a rel="noreferrer noopener" href="https://www.vaadin.com" data-type="URL" data-id="https://www.vaadin.com" target="_blank">Vaadin</a> und eine nähere Besprechung würde endgültig den Rahmen dieser Artikelserie sprengen. Ihr könnt aber die Entwicklung der Software in meinen Live-Codings auf Twitch (und später auf Youtube) gerne verfolgen.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Auch die Software-Tests sollen hier während des Maven-Builds stattfinden, sodass wir uns beim Workflow nicht weiter darum kümmern müssen. </p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading --></p>
<h2>Der GitHub Workflow</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Und zum Workflow kommen wir jetzt. Er versteckt sich in der Datei <a rel="noreferrer noopener" href="https://github.com/Paladins-Inn/delphi-council/blob/development/.github/workflows/ci.yml" data-type="URL" data-id="https://github.com/Paladins-Inn/delphi-council/blob/development/.github/workflows/ci.yml" target="_blank"><kbd>./github/workflows/ci.yml</kbd></a>. Natürlich kann man mehrere Workflows haben. Einfach eine weitere Datei daneben legen und es sind schon zwei Workflows. Aber wir werden uns die vorhande Datei mal von Oben nach unten anschauen.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"yaml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">## This is basic continuous integration build for your Quarkus application.

name: CI

on:
  push:
    branches: [ main ]

jobs:</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Der Kopf der Datei. Hier definieren wir den Namen des Workflows, wie er uns später auch von GitHub angezeigt wird.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":775,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-17-at-07.51.06-1024x382.png" alt="" class="wp-image-775"/></figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>Außerdem definieren wir, wann der Workflow ausgeführt werden soll. Hier soll er bei jedem Push im Branch main ausgeführt werden. Damit ist dies eigentlich kein CI-Workflow mehr sondern eher ein Release-Workflow. Aber wenn man unter branches noch <kbd>development</kbd> eintragen würde, wäre es wieder ein CI-Workflow, ignorieren wir diese Information also erstmal. Denn jetzt kommen die Definitionen der <code>jobs</code>. Jobs sind die Schritte im Workflow, die jeweils einem Runner zugewiesen werden <em>können</em>. Dazu nutzt man den Parameter <kbd>runs-on</kbd> und definiert dann die einzelnen Schritte (steps), die auf diesem Runner ausgeführt werden sollen:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"yaml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">jobs:
  java-build:
    runs-on: [ java ]
    steps:
      ...

  container-build:
    runs-on: [ podman ]
    needs: java-build
    steps:
      ...</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Dieser Workflow hat also zwei Schritte (<kbd>java-build</kbd> und <kbd>container-build</kbd>). Diese habe ich so gewählt, da ich einen runner für <kbd>java</kbd> (mit maven, gradle und wie oben beschrieben auch node.js) und einen Runner für <kbd>buildah</kbd> und <kbd>podman</kbd> (für Containerbuilds und Management) habe und diese so den verschiedenen Runnern zuweisen kann.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Und mittels des <kbd>needs</kbd>-Eintrags sorge ich dafür, dass cer container-build nicht parallel startet sondern erst nach dem java-build, da der Container natürlich die Software benötigt, die dort gebaut wird.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":3} --></p>
<h3>Der Java-Build-Teil des Workflows</h3>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Schauen wir uns den Java-Build an, zerfällt er wieder in drei Teile. Zuerst wird der Build vorbereitet, indem die Sourcen aus git ausgecheckt werden (mit der Aktion <kbd>actions/checkout@v2</kbd>) und die Java-Umgebung wird vorbereitet (Aktion <kbd>actions/setup-java@v1</kbd>). Die einzelnen Steps haben Namen und Ids. Welche Aktion genutzt wird, wird per <kbd>uses</kbd> definiert und mittels <kbd>with</kbd> werden die Aktionen mit Parametern versehen. So wähle ich per <kbd>java-version</kbd> hier Java11 aus.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"yaml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">jobs:
  java-build:
    runs-on: [ java ]
    steps:
      - name: Checkout sources
        id: checkout-sources
        uses: actions/checkout@v2

      - name: Set up JDK 11
        id: setup-java
        uses: actions/setup-java@v1
        with:
          java-version: 11</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Nachdem die Umgebung vorbereitet ist, können wir jetzt den Java-Build starten. Hierzu rufen wir Maven auf:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"yaml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">      - name: Build
        id: build-java
        run: mvn package -B -Pproduction</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Damit ist der Maven-Build gelaufen und unsere Artifakte liegen alle unterhalb des Verzeichnisses <kbd>./target</kbd>. Ja, durch die oben beschriebenen Änderungen am pom.xml, nutzen wir drei Artifakte:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list {"ordered":true} --></p>
<ol>
<li>Das jar-File mit der Anwendung <kbd>./target/delphi-council-is-@project.version@.jar</kbd> (um in der Spring-Schreibweise zu bleiben)</li>
<li>Das Dockerfile <kbd>./target/classes/Dockerfile</kbd></li>
<li>Das Helmchart <kbd>./target/helm/delphi-council-is</kbd></li>
</ol>
<p><!-- /wp:list --></p>
<p><!-- wp:paragraph --></p>
<p>Die Versionsnummer will ich nur an einer Stelle pflegen: im Maven-Buildfile unter project-&gt;version. Daher habe ich ja die Resourcen definiert, die diese Version überall hin ersetzen. Und die Version brauche ich mindestens für das Sichern der Artefakte auf GitHub. Daher extrahiere ich den <kbd>APP_NAME</kbd> und die <kbd>APP_VERSION</kbd> aus dem <kbd>Dockerfile</kbd> und merke mir die Variablen als <code>IMAGE</code> und <code>VERSION</code> in den <kbd>$GITHUB_ENV</kbd> (diese werden bei jedem step ins Environment geschrieben und machen diese als <kbd>${{ env.IMAGE }}</kbd> und <kbd>${{ env.VERSION }}</kbd> für die steps verfügbar. Ich gebe diese Variablen als Information aus und nutze sie zum Upload nach GitHub. Hierzu nutze ich die Aktion <kbd>actions/upload-artifact@v2</kbd> mit der Liste der Dateien, die zu sichern sind. Damit wird ein Archiv mit dem konfigurierten Namen (<code>dci</code>) erstellt. Die Besonderheit ist, dass der gemeinsame Pfad der Dateien möglichst weit gekürzt wird. Im Archiv stehen also nicht die Dateien <kbd>./target/delphi-council-is-${{ env.VERSION }}.jar</kbd>, <kbd>./target/classes/Dockerfile</kbd> und <kbd>./target/helm/...</kbd> - nein, im Archiv sind <kbd>./delphi-council-is-${{ env.VERSION }}.jar</kbd>, <kbd>./classes/Dockerfile</kbd> und <kbd>./helm/...</kbd>; daran müssen wir uns erinnern, wenn wir im zweiten Teil des Flows auf diese Dateien zugreiffen wollen.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"yaml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">      - name: Set Image name and version
        run: |
          echo "IMAGE=$(cat target/classes/Dockerfile | grep APP_NAME= | head -n 1 | grep -o '".*"' | sed 's/"//g')" >> $GITHUB_ENV
          echo "VERSION=$(cat target/classes/Dockerfile | grep APP_VERSION= | head -n 1 | grep -o '".*"' | sed 's/"//g')" >> $GITHUB_ENV

      - name: Image name and version
        run: echo "Working on image '${{ env.IMAGE }}:${{ env.VERSION }}'."

      - name: Upload Artifact
        id: upload-jar
        uses: actions/upload-artifact@v2
        with:
          name: dci
          path: |
            target/delphi-council-is-${{ env.VERSION }}.jar
            target/classes/Dockerfile
            target/helm
          retention-days: 1</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Damit ist der eigentliche Build der Software abgeschlossen und die Ergebnisse liegen im Archiv <code>dci</code> bei den GitHub Actions.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":777,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-17-at-08.42.02-1024x730.png" alt="" class="wp-image-777"/><br />
<figcaption>Hier findet man bei den Workflow-Ausführungen die erzeugte Datei. Da ich sie nur für 1 Tag aufbewahre, ist sie hier als expired markiert.</figcaption>
</figure>
<p><!-- /wp:image --></p>
<p><!-- wp:heading {"level":3} --></p>
<h3>Der Container-Build-Teil des Workflows</h3>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Jetzt kommen wir zum 2. Teil des Workflows, dem Container-Build. Hier wird erstmal definiert, dass er einen Runner mit dem Tag <kbd>podman</kbd> nutzen soll (da ich nur dort die notwendige Software installiert habe. Außerdem wird definiert, dass dieser Schritt erst nach erfolgreichem <kbd>java-build</kbd> laufen darf. Das git-Repository wird wieder ausgecheckt und das Archiv <code>dci</code> aus dem Java-Build heruntergelanden sowie wieder die Umgebungsvariablen erzeugt (es ist ein anderer Runner, damit sind diese natürlich nicht verfügbar).</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"yaml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">  container-build:
    runs-on: [ podman ]
    needs: java-build
    steps:
      - name: checkout sources
        id: checkout-sources
        uses: actions/checkout@v2

      - name: retrieve jar and dockerfile
        id: retrieve-jar
        uses: actions/download-artifact@v2
        with:
          name: dci

      - name: Set Image name and version
        run: |
          echo "IMAGE=$(cat classes/Dockerfile | grep APP_NAME= | head -n 1 | grep -o '".*"' | sed 's/"//g')" >> $GITHUB_ENV
          echo "VERSION=$(cat classes/Dockerfile | grep APP_VERSION= | head -n 1 | grep -o '".*"' | sed 's/"//g')" >> $GITHUB_ENV</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Als erstes nutzen wir <kbd>buildah</kbd> über die Aktion <kbd>redhat-actions/buildah-build@v2</kbd>, um einen <kbd>Dockerfile</kbd>-basierten container-Build anzustoßen. <kbd>./classes/Dockerfile</kbd> ist die Datei aus dem Archiv <kbd>dci</kbd> und der Build soll das aktuelle Verzeichnis als Basis nutzen. Außerdem braucht das Image einen Namen (<kbd>image</kbd>) und <kbd>tags</kbd> (ich tagge das Image mit drei tags):<kbd> ${{ env.VERSION }}</kbd> (die Version aus dem Maven-Buildfile), <code>latest</code> und die Git Commit-Id (<kbd>${{ github.sha }}</kbd>).</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"yaml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">      - name: Buildah
        id: build-container
        uses: redhat-actions/buildah-build@v2
        with:
          image: ${{ env.IMAGE }}
          tags: ${{ env.VERSION }} latest ${{ github.sha }}
          dockerfiles: |
            ./classes/Dockerfile
          context: ./</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Nach dem Build muss der erzeugte Container natürlich noch in die Container-Registry geschoben werden. Dies erledigt die Aktion <code><kbd>redhat-actions/push-to-registry@v2</kbd></code>, die dazu diverse Parameter braucht. Unter anderem auch Credentials für die Registry und natürlich das eigentliche Repository auf der Registry, in das das Image geschoben werden soll.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"yaml"} --></p>
<pre class="wp-block-syntaxhighlighter-code">      - name: Push To quay
        id: push-to-quay
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ env.IMAGE }}
          tags: ${{ env.VERSION }} latest ${{ github.sha }}
          registry: ${{ secrets.QUAY_REPO }}
          username: ${{ secrets.QUAY_USER }}
          password: ${{ secrets.QUAY_TOKEN }}</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Damit man nicht seinen persönlichen Account nutzen muss, legt man auf quay.io einen Robot-Account an. Dazu kommen wir im nächsten Teil. Ein solcher Account hat einen Benutzernamen und ein Token, dass hier in der Aktion als username bzw. password gesetzt werden müssen. Außerdem muss man den Pfad zum Repository angeben. Die Secrets werden im Repository definiert:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":780,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-17-at-10.41.15-1024x764.png" alt="" class="wp-image-780"/></figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>In einem normalen Repository würden <kbd>QUAY_TOKEN</kbd> und <kbd>QUAY_USER</kbd> auch unter "Repository secrets" stehen. Da ich diese aber für eine Organisation angelegt habe, werden sie hier zwar gelistet aber bei der Organisation gepflegt. Für den Workflow macht dies keinen Unterschied, Ihr könnt sie auch direkt im Repository anlegen. Ich habe mehrere Projekte und will nur einen Quay-Account pflegen und habe daher den Weg über die Organisation gewählt.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>In das <kbd>QUAY_REPO</kbd> müsst Ihr den kompletten Pfad angeben, bei mir ist das <kbd>quay.io/klenkes74</kbd>. Der QUAY_USER beinhalten den Benutzernamen für das quay-Repository, der QUAY_TOKEN das generierte Token für den Benutzer. Aber um quay.io kümmern wir uns im nächsten Teil der Artikelserie.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":3} --></p>
<h3>Sichere und unsichere Github Actions</h3>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>GitHub weißt darauf hin, dass beim Einsatz eigener Runner natürlich die Sicherheit nicht vernachlässigt werden darf. Immerhin können Fremde einen Pullrequest stellen und wenn man da nicht aufpasst, kann natürlich auch der Workflow verändert werden. Daher bietet GitHub eine Konfiguration an, welche Runner erlaubt sind und welche nicht. Hier müsst Ihr auswählen, wem Ihr vertraut. Ich vertraue allen GitHub-Actions und denen von verifizierten Erstellern:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":784,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-17-at-11.01.52-1024x686.png" alt="" class="wp-image-784"/><br />
<figcaption>Sicherheitseinstellungen für Actions auf github.com</figcaption>
</figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>Damit sind wir am Ende der Github-Repository-Konfiguration angekommen. Als nächstes schauen wir uns an, wie wir an ein Quay-Repository kommen und dort einen eigenen Robot-Account für Github Actions anlegen.</p>
<p><!-- /wp:paragraph --></p>
