---
layout: page
status: publish
published: true
title: CI/CD mit Maven, GitHub Actions, quay.io und OpenShift
thumbnail: /assets/thumbnail/ni0ByXc-300x225.jpg
author:
  display_name: klenkes74
  login: klenkes74
  email: roland@lichti.de
  url: ''
author_login: klenkes74
author_email: roland@lichti.de
wordpress_id: 757
wordpress_url: https://www.lichti.de/?p=757
date: '2021-04-17 08:00:00 +0200'
date_gmt: '2021-04-17 06:00:00 +0200'
categories:
- Softwareschnipsel
- OpenShift
- Deutsch
tags:
- build
- Java
- maven
- Software
- quay.io
- GitHub
- GitHub Actions
- CI/CD
- Pipeline
comments: []
---
<p><!-- wp:paragraph {"ampFitText":true} --><br />
<amp-fit-text layout="fixed-height" min-font-size="6" max-font-size="72" height="80">
<p>In der Softwareentwicklung gehören CI/CD-Pipelines inzwischen zum guten Ton. Allerdings braucht man hierfür einiges an Infrastruktur, um den Buildprozess so weit zu automatisieren. In dieser kurzen Artikelserie will ich eine mögliche Pipeline auf Basis von GitHub, GitHub Actions, quay.io und OpenShift-basierten Runnern für GitHub Actions betrachten. Ich nutze hier OpenShift, da ich einen OKD-Cluster zu Verfügung habe, aber die Runner lassen sich auch 1:1 für Kubernetes-Cluster nutzen.</p>
<p></amp-fit-text><br />
<!-- /wp:paragraph --></p>
<p><!-- wp:paragraph {"ampFitText":true} --><br />
<amp-fit-text layout="fixed-height" min-font-size="6" max-font-size="72" height="80">
<p>Meine Software ist eine Java spring-boot-Anwendung, die per Maven gebaut wird. Aber dies betrifft nur den kurzen build-Teil der Pipeline und man kann die gleiche Methode auch für Gradle-Builds oder auch für node.js nutzen - man muss gegebenenfalls einen anderen Build-Runner aussuchen.</p>
<p></amp-fit-text><br />
<!-- /wp:paragraph --></p>
<p><!-- wp:more --><br />
<!--more--><br />
<!-- /wp:more --></p>
<p><!-- wp:paragraph --></p>
<p>Dieser Teil der Artikelserie verdeutlicht das Zusammenspiel der Komponenten und bietet so eine Übersicht. Die einzelnen Bestandteile werden dann in den folgenden Artikeln besprochen.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":763,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/FA4C2652-DAAE-4B94-9017-B29C7807216D_1_201_a-1024x768.jpeg" alt="" class="wp-image-763"/><br />
<figcaption>Überblick über die Komponenten, die wir hier betrachten werden.</figcaption>
</figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>Wir nutzen hier die Services von Github (als git-Repository und als Steuerung für unsere Pipeline, bei Github "Workflow" genannt), quay.io (als Container-Repository, das App-Repository ist nur als zukünftige Erweiterung der Pipeline eingetragen) und natürlich unseren eigenen OCP-Cluster (bei mir noch OKD 3.11).</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Die Applikation kommt aus einem weiteren Projekt von mir, aber ist in diesem Kontext Nebensache. Sie wird per Maven gebaut und dann per podman-Build in einen Container gegossen. Den java-Runner werden wir hier im Rahmen der Artikel selbst erweitern, um den Node-Part der Anwendung ebenfalls hier bauen zu können. Und weil wir gerade dabei sind, packen wir auch noch gradle als Buildsystem in den Container. Aber dazu mehr im entsprechenden Artikel dieser Serie.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Das mag jetzt nach einem großen Haufen an Komponenten aussehen, aber neben dem Runner-Projekt auf OCP und den Repositories auf Github (source) und quay.io (Container) sind es noch zwei Dateien im Source-Repository (.github/workflow/ci.yaml und src/main/docker/Dockerfile), die unsere Pipeline vervollständigen werden.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Schauen wir uns den Ablauf der Pipeline mal systematisch an:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":764,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/48CD00D2-4A80-45CD-9F63-4AEA00417D7A_1_105_c-1024x363.jpeg" alt="" class="wp-image-764"/><br />
<figcaption>Ablauf eines Github Workflows mit Github Actions</figcaption>
</figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>So ein Workflow funktioniert ganz einfach. Nach dem Auslöser (normalerweise ein commit) führt er einfach der Reihe nach alle definierten Aktionen aus. Wenn ein Fehler auftritt, bricht er ab. Wurden alle Aktionen ausgeführt, beendet sich der Workflow. Nichts besonderes also.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Wir werden einen einfachen Workflow haben, der die Software</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list {"ordered":true} --></p>
<ol>
<li>mittels Maven auf dem java-runner baut,</li>
<li>den Container mittels buildah baut und</li>
<li>ihn dann per podman nach quay.io hochlädt.</li>
</ol>
<p><!-- /wp:list --></p>
<p><!-- wp:paragraph --></p>
<p>Es kommen neben diesen grundsätzlichen Arbeiten noch ein paar technische Aktionen (auschecken des Codes, aufsetzen der Build-Umgebung, ...) Also nichts, wovor man sich fürchten müsste.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Damit haben wir unseren Überblick. Im nächsten Teil werden wir uns um das <a href="https://www.lichti.de/2021/04/19/ci-cd-2/">Aufsetzen des Github-Repositories</a> (und die Definition des Workflows dort) kümmern.</p>
<p><!-- /wp:paragraph --></p>
