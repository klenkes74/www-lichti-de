---
layout: page
status: publish
published: true
title: GitHub Runner in OpenShift/kubernetes
thumbnail: /assets/thumbnail/ni0ByXc-300x225.jpg
author:
  display_name: klenkes74
  login: klenkes74
  email: roland@lichti.de
  url: ''
author_login: klenkes74
author_email: roland@lichti.de
wordpress_id: 799
wordpress_url: https://www.lichti.de/?p=799
date: '2021-04-23 08:00:00 +0200'
date_gmt: '2021-04-23 06:00:00 +0200'
categories:
- Softwareschnipsel
- OpenShift
- Deutsch
tags:
- build
- Java
- maven
- Software
- quay.io
- GitHub
- GitHub Actions
- CI/CD
- Pipeline
comments: []
---
<p><!-- wp:paragraph --></p>
<p>Nachdem wir uns im letzten Teil das <a rel="noreferrer noopener" href="https://www.lichti.de/?p=786" target="_blank">quay.io-Container-Repository</a> aufgesetzt haben Das Aufsetzen der OpenShift basierten GitHub Action Runner ist der letzte Schritt, den wir noch brauchen, um die CI-Pipeline fertig zu haben. Und darum kümmern wir uns in diesem Artikel.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:more --><br />
<!--more--><br />
<!-- /wp:more --></p>
<p><!-- wp:paragraph --></p>
<p>Ich gebe zu, ich habe es mir eigentlich recht bequem gemacht, denn hier haben schon meine Kollegen von Red Hat sehr viel vorbereitet. Es gibt ein Helm-Chart und selbst einige Runner haben sie schon im Angebot. Nur beim Java-Runner musste ich etwas nacharbeiten, da ich für Vaadin neben dem Java 11 auch noch node.js im gleichen Runner gebraucht habe (Vaadin kompiliert den Frontendteil zusammen mit dem Java-Anteil). Aber dazu kommen wir später.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Als erstes brauche ich ein Projekt in meiner OpenShift-Umgebung (nunja, ich nutze hier meine OKD-Installation, die noch immer in Version 3.11 läuft, aber wenn Ihr ein OpenShift 4 habt, sollte es nicht viel anders sein).</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"bash"} --></p>
<pre class="wp-block-syntaxhighlighter-code">$ oc new-project github-runner
Now using project "github-runner" on server "https://console.das.wuesstet.ihr.wohl.gerne:8443".

You can add applications to this project with the 'new-app' command. For example, try:

    oc new-app django-psql-example

to build a new example application in Python. Or use kubectl to deploy a simple Kubernetes application:

    kubectl create deployment hello-node --image=gcr.io/hello-minikube-zero-install/hello-node

$</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Natürlich muss man dazu eingeloggt sein. Aber wie das geht, wisst Ihr bei eurem Cluster selbst.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Da builda-sa mit erhöhten Rechten laufen muss, erledige ich das hier gleich. Immer daran denken, dass dies natürlich ein Bruch der Security-Sandbox ist. Ob ihr dazu bereit seid, müsst Ihr selbst abwägen.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"bash"} --></p>
<pre class="wp-block-syntaxhighlighter-code">$ oc create -f - &lt;&lt;EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: buildah-sa
EOF
$ oc adm policy add-scc-to-user privileged -z buildah-sa
securitycontextconstraints.security.openshift.io/privileged added to: ["system:serviceaccount:github-runner:buildah-sa"]
$</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Jetzt haben wir den privilegierten Benutzer, damit buildah seine Arbeit verrichten kann. Allerdings brauchen wir noch ein GitHub PAT (personal access token) - ich verweise aus Faulheit auf die <a rel="noreferrer noopener" href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token" target="_blank">recht gute Dokumentation seitens GitHub</a> mit der Anmerkung, dass wir mindestens die Berechtigung <kbd><span class="has-inline-color has-vivid-cyan-blue-color">repo</span></kbd> benötigt. Dieses Token und den Eigentümer des GitHub-Repositories schreiben wir uns mal in Umgebungsvariablen, denn wir werden sie öfter benötigen:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code --></p>
<pre class="wp-block-syntaxhighlighter-code">$ export GITHUB_PAT=&lt;Personal Access Token>
$ export GITHUB_OWNER=&lt;Eigentümer eures Repositories>
$ export GITHUB_REPO=&lt;Repository></pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Den letzten Eintrag braucht Ihr nur, wenn ihr den Runner an ein bestimmtes Repository binden wollt. Wenn Ihr es euch für mehrere Projekte einfach machen wollt, legt bei GitHub eine Organisation an und bindet die Runner an die Organisation - dann könnt ihr die Repos innerhalb der Organisation mit den gleichen Runnern glücklich machen und müsst nicht jedes Repository bei GitHub einzeln mit Runnern bespaßen.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Wir brauchen natürlich das Helm-Chart, um die Runner zu installieren. Das bekommen wir auch von GitHub:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"bash"} --></p>
<pre class="wp-block-syntaxhighlighter-code">$ helm repo add openshift-actions-runner https://redhat-actions.github.io/openshift-actions-runner-chart
$</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Jetzt kann der Spaß losgehen:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code {"language":"bash"} --></p>
<pre class="wp-block-syntaxhighlighter-code">$ helm upgrade --install buildah-runner openshift-actions-runner/actions-runner --set-string githubPat=$GITHUB_PAT --set-string githubOwner=$GITHUB_OWNER --set-string runnerImage=quay.io/redhat-github-actions/buildah-runner --set-string privileged=true --set runnerLabels="{podman,buildah}"
$ helm upgrade --install java-runner-11 openshift-actions-runner/actions-runner --set-string githubPat=$GITHUB_PAT --set-string githubOwner=$GITHUB_OWNER --set-string runnerImage=quay.io/klenkes74/java-runner-with-maven --set-string runnerTag=latest --set runnerLabels="{java,java-11,maven,gradle,ant,ivy}"
$ </pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Ihr könnt auch gerne noch die anderen Runner der Red Hat Community of Practice installieren - es gibt noch einen allgemeinen Runner, einen Runner für node.js und einen k8s-tools-runner, damit Ihr per GitHub-Action auch direkt euren Cluster konfigurieren könnt. Aber für unsere Anwendung benötigen wir nur den Java- und den buildah/podman-Runner.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Dem aufmerksamen Leser wird auch noch etwas am java-runner-11 aufgefallen sein. Er lädt kein Image von <kbd>quay.io/redhat-github-actions</kbd> (wo es auch einen java-11-runner gibt), sondern einen von mir bereitgestellten Runner von <kbd>quay.io/klenkes74/java-runner-with-maven</kbd>. Das liegt daran, dass der normale Runner kein Maven beinhaltet. Und weil ich gerade dabei war, habe ich noch gradle, ant und ivy und - wie oben schon erwähnt - node.js mit reingeworfen. Wider erwarten findet er auch bereits bei mir unbekannten Projekten innerhalb von AWS Anwendung - wie ich durch die quay.io-Statistiken erfahren durfte. Wer sich für den Runner und seinen Bau interessiert, kann sich das auf <a rel="noreferrer noopener" href="https://github.com/klenkes74/java-runner-with-maven" target="_blank">https://github.com/klenkes74/java-runner-with-maven</a> anschauen. Vielleicht schreibe ich da auch einen Blog drüber - aber eigentlich ist das nur ein Dockerfile, dass diverse Sachen nachinstalliert.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Und jetzt sollten die Pods laufen und sich zu Github verbinden. Auf OpenShift-Seite sieht es ungefähr so aus:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:syntaxhighlighter/code --></p>
<pre class="wp-block-syntaxhighlighter-code">$ oc get pod
NAME                                READY   STATUS    RESTARTS   AGE
buildah-runner-774f989c86-sc96s     1/1     Running   0          13d
java-runner-11-79f5c4f49d-rlmjt     1/1     Running   0          20h
$</pre>
<p><!-- /wp:syntaxhighlighter/code --></p>
<p><!-- wp:paragraph --></p>
<p>Und auf Github findet man es unter den Settings (bei mir natürlich bei der Organisation und nicht im Repository):</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":810,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-19-at-19.49.09.png" alt="" class="wp-image-810"/></figure>
<p><!-- /wp:image --></p>
<p><!-- wp:image {"id":811,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-19-at-19.50.07-1024x910.png" alt="" class="wp-image-811"/></figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>Voilá, die Github-Runner laufen und verrichten ihre Arbeit. Ihr könnt euch auch über die OKD-Console den Output anschauen:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image {"id":812,"sizeSlug":"large","linkDestination":"none"} --></p>
<figure class="wp-block-image size-large"><img src="https://www.lichti.de/wp-content/uploads/2021/04/Screenshot-2021-04-19-at-19.53.58-1024x536.png" alt="" class="wp-image-812"/></figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>Jetzt haben wir alles zusammen. Ein Push in die konfigurierten Branches (bei mir <kbd>development</kbd>) wird den Workflow CI auslösen und am Schluss liegt dann - wenn alles funktionierte - das Container Image im quay.io-Repository.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Inzwischen habe ich im Projekt noch CodeQL-Checks hinzugefügt und einen zweiten Workflow für Releases auf den <kbd>main</kbd>-Branch gesetzt. Aber das ist dann nochmal ein neues Thema.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Ich wünsche allen viel Spaß mit Github-Actions ohne dabei auf die Minuten schauen zu müssen.</p>
<p><!-- /wp:paragraph --></p>
